
% Load annotations json. Generated by Wei's code gen_annotation_map.py
annotations=loadjson('~/tracing/sid_by_annotation.json');

% Return all skeleton IDs for R and L ORNs

ORNs_Left=annotations.Left_0x20_ORN;
ORNs_Right=annotations.Right_0x20_ORN;

%exclude unilateral ORNs for now

ORNs_Right(find(ORNs_Right == 499879))=[];
ORNs_Left(find(ORNs_Left == 426230))=[];
ORNs_Left(find(ORNs_Left == 401378))=[];
%
% %exclude ORN 8 because it was temporarily unilateral on 8/5 for testing
% ORNs_Left(find(ORNs_Left == 593865))=[];

ORNs=[ORNs_Left, ORNs_Right];



%for each ORN

for o=1:length(ORNs)
    tic
    % Step #1 load ORN skeletons
    
    workingSkel=loadjson(['~/tracing/skeletons/',num2str(ORNs(o)),'.json']);
    
    
    % STEP 2: generate the directed, weighted adjacency matrix and graph obj
    %also return the list of skeleton vertex names that went into this
    %adjacency matrix
    
    
    [adjMat, skelVertNames]=getSkelAdjMat_DW_ORN(workingSkel);
    
    
    %matrix is transposed to reflect my view of parent/child relationships,
    %this is troublesome because I dont think it should be the
    %case******!!!!!!!! TALK W? WEI ABOUT THIS
    
    adjMat=adjMat';
    
    %make a biograph object out of it
    G=biograph(adjMat);
    
    
    % This loop runs over the the verts that will go into the Adj Mat and looks for
    % the start of the left axon/s
    
    axonCounterL=1;
    leftStart=[];
    
    for v =1:length(skelVertNames)
        
        if isempty(cell2mat(workingSkel.vertices.(cell2mat(skelVertNames(v))).labels)) == 1
        else
            
            if regexp(cell2mat(workingSkel.vertices.(cell2mat(skelVertNames(v))).labels),'left axon') == 1
                
                leftStart(axonCounterL)=v;
                
                %leftStartNodeName=skelVertNames(v)
                axonCounterL=axonCounterL+1;
                
            else
            end
        end
    end
    
    
    for s = 1:length(leftStart)
        % step 4 identify all nodes that are descendants of the left axon start
        
        
        %Traverse the graph from the left axon start vertex, as long as this node has
        %all the glomerular collateral as descendants and no connection back to its
        %parent this should yield the indicies of all nodes (from skelVertNames)
        %involved in the collateral
        
        leftAxonInds=G.traverse(leftStart(s));
        
        
        % Step 5 look for low confidence edges in this sub-arbor
        
        
        lowConCounter=1;
        
        for v=leftAxonInds
            
            if   workingSkel.vertices.(cell2mat(skelVertNames(v))).confidence < 5
                
                lowConVerts{o,1}(lowConCounter,1)=workingSkel.vertices.(cell2mat(skelVertNames(v))).x;
                lowConVerts{o,1}(lowConCounter,2)=workingSkel.vertices.(cell2mat(skelVertNames(v))).y;
                lowConVerts{o,1}(lowConCounter,3)=workingSkel.vertices.(cell2mat(skelVertNames(v))).z;
                
                lowConCounter=lowConCounter+1;
                
            else
            end
            
            
        end
    end
    
    % This loop runs over the the verts that will go into the Adj Mat and looks for
    % the start of the right axons
    
    axonCounterR=1;
    rightStart=[];
    
    for v =1:length(skelVertNames)
        
        if isempty(cell2mat(workingSkel.vertices.(cell2mat(skelVertNames(v))).labels)) == 1
        else
            
            if regexp(cell2mat(workingSkel.vertices.(cell2mat(skelVertNames(v))).labels),'right axon') == 1
                
                rightStart(axonCounterR)=v;
                %leftStartNodeName=skelVertNames(v)
                axonCounterR=axonCounterR+1;
                
            else
            end
        end
    end
    
    
    for s = 1:length(rightStart)
        % step 4 identify all nodes that are descendants of the right axon starts
        
        
        %Traverse the graph from the left axon start vertex, as long as this node has
        %all the glomerular collateral as descendants and no connection back to its
        %parent this should yield the indicies of all nodes (from skelVertNames)
        %involved in the collateral
        
        rightAxonInds=G.traverse(rightStart(s));
        
        
        % Step 5 We want to calculate the total path length of this subgraph
        
        %NOTE:NEED SOME WAY TO CHECK THIS, nC answer is slightly different
        
        %For now I guess I am going to do this by pulling values from my adjacency
        %matrix, there is probably a smarter/more elegant way to do this
        
        
        lowConCounter=1;
        
        for v=rightAxonInds
            
            if   workingSkel.vertices.(cell2mat(skelVertNames(v))).confidence < 5
                
                lowConVerts{o,2}(lowConCounter,1)=workingSkel.vertices.(cell2mat(skelVertNames(v))).x;
                lowConVerts{o,2}(lowConCounter,2)=workingSkel.vertices.(cell2mat(skelVertNames(v))).y;
                lowConVerts{o,2}(lowConCounter,3)=workingSkel.vertices.(cell2mat(skelVertNames(v))).z;
                
                lowConCounter=lowConCounter+1;
                
            else
            end
        end
        
    end
    toc
end



cd('~/Documents/MATLAB/tracingCode2/wfly1_Manuscript/')
save('lowConVerts', 'lowConVerts')


figure()

counter=1;
for i=1:25
    
    
    
    for v=1:size(lowConVerts{i,1},1)
        
        
        
        for j=1:50
          
            if i == j
                
            else
                
                
                for v2=1:size(lowConVerts{j,1},1)
                    
                   
                        
               if pdist([lowConVerts{i}(v,:);lowConVerts{j}(v2,:)])<=2500
                   
                   spotToCheck(counter,:)=lowConVerts{i,1}(v,:);
                        
                        counter=counter+1;
               else
               end
                        
                    
                end
            
                
                end    
            end
        end
        
%         if isempty(dists_working)==1
%             
%             min_Dists{i}(v)=NaN;
%         else
%             min_Dists{i}(v)=min(dists_working);
%             dists_working=[];
%         end
    end
    
    
    

    
allMinDists=[];

for i=1:25
    
    allMinDists=[allMinDists,min_Dists{i}]
end
    
    
    
    

