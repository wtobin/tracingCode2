%% Load annotations and connectors


% Load annotations json. Generated by Wei's code gen_annotation_map.py
annotations=loadjson('~/tracing/sid_by_annotation.json');

% Return all skeleton IDs for R and L ORNs

ORNs_Left=annotations.Left_0x20_ORN;
ORNs_Right=annotations.Right_0x20_ORN;

ORNs=[ORNs_Left, ORNs_Right];

%return all skeleton IDs of DM6 PNs
% PNs=annotations.PN;
PNs=sort(annotations.DM6_0x20_PN);
% PNs=annotations.DM6_0x20_PN;


% return all skel IDs with *LN* in fieldname
Fn = fieldnames(annotations);
selFn = Fn(~cellfun(@isempty,regexp(Fn,'LN')));

LNs=[];
for i = 1:numel(selFn)
    LNs=[LNs, annotations.(selFn{i})];
end

LNs = unique(LNs);

%
% LNs=annotations.LN;
% LNs=[LNs, annotations.potential_0x20_LN];
% LNs=[LNs, annotations.Prospective_0x20_LN];
% LNs=[LNs, annotations.Likely_0x20_LN];


%Load the connector structure
load('~/tracing/conns.mat')

%gen conn fieldname list
connFields=fieldnames(conns);


%%

numPostEl=cell(5,1);
numPNs=cell(5,1);


for c = 1:length(connFields)
    
    curConnID=cell2mat(connFields(c));
    
    %Make sure the connector doesnt have an empty presynaptic field
    if isempty(conns.(curConnID).pre) == 1
        
        %or an empty postsynaptic field, if its empty it will be a cell
    elseif iscell(conns.(curConnID).post) == 1
        
    else
        
        pre=conns.(curConnID).pre;
        post=conns.(curConnID).post;
        
        if ismember(pre,ORNs)==1 && sum(ismember(unique(post),PNs))>0
            
            usedFlag=0;
            
            if ismember(PNs(1),post) == 1 %&& usedFlag==0
                
                numPostEl{1}=[numPostEl{1},numel(post)];
                numPNs{1}=[numPNs{1},sum(ismember(unique(post),PNs))];
                usedFlag=usedFlag+1;
                
            else
            end
            
            if ismember(PNs(2),post) == 1 %&& usedFlag==0
                
                numPostEl{2}=[numPostEl{2},numel(post)];
                numPNs{2}=[numPNs{2},sum(ismember(unique(post),PNs))];
                usedFlag=usedFlag+1;
                
            else
            end
            
            if ismember(PNs(3),post) == 1  %&& usedFlag==0
                
                numPostEl{3}=[numPostEl{3},numel(post)];
                numPNs{3}=[numPNs{3},sum(ismember(unique(post),PNs))];
                usedFlag=usedFlag+1;
                
            else
            end
            
            if ismember(PNs(4),post) == 1 %&& usedFlag==0
                
                numPostEl{4}=[numPostEl{4},numel(post)];
                numPNs{4}=[numPNs{4},sum(ismember(unique(post),PNs))];
                usedFlag=usedFlag+1;
                
            else
            end
            
            if ismember(PNs(5),post) == 1 %&& usedFlag==0
                
                numPostEl{5}=[numPostEl{5},numel(post)];
                numPNs{5}=[numPNs{5},sum(ismember(unique(post),PNs))];
                usedFlag=usedFlag+1;
                
            else
            end
            
            
            
            
            
        end
        
    end
    
    
    
end


%% Plotting

figure()
set(gcf,'color','w')


h1=histogram(numPostEl{1},'Normalization','probability');
hold on


histogram(numPostEl{2},h1.BinEdges,'Normalization','probability')
histogram(numPostEl{3},h1.BinEdges,'Normalization','probability')
histogram(numPostEl{4},h1.BinEdges,'Normalization','probability')
histogram(numPostEl{5},h1.BinEdges,'Normalization','probability')

legend({'Left','Right'})
xlabel('Number of Postsynaptic Profiles')
ylabel('Prob Normalized Freq')
set(gca,'FontSize',18)

grpdForBoxplot=[[numPostElL',zeros(size(numPostElL,2),1)];...
    [numPostElR',ones(size(numPostElR,2),1)]];


figure()
set(gcf,'color','w')
boxplot(grpdForBoxplot(:,1),grpdForBoxplot(:,2),'Labels',...
    {'Left Syns','Right Syns'},'Notch','on')

ylabel('Number of Postsynaptic Profiles')
set(gca,'FontSize',18)


figure()
set(gcf,'color','w')
h2=histogram((numPNsL./numPostElL),'Normalization','probability');
hold on
histogram((numPNsR./numPostElR),h2.BinEdges,'Normalization','probability')
legend({'Left Syns','Right Syns'})
xlabel('Fraction of Post Profiles That are PNs')
ylabel('Prob Normalized Freq')
set(gca,'FontSize',18)

grpdForBoxplot=[[(numPNs{1}./numPostEl{1})',zeros(size(numPostEl{1},2),1)];...
    [(numPNs{2}./numPostEl{2})',ones(size(numPostEl{2},2),1)];...
    [(numPNs{3}./numPostEl{3})',2*ones(size(numPostEl{3},2),1)];...
    [(numPNs{4}./numPostEl{4})',3*ones(size(numPostEl{4},2),1)];...
    [(numPNs{5}./numPostEl{5})',4*ones(size(numPostEl{5},2),1)]];


figure()
set(gcf,'color','w')
boxplot(grpdForBoxplot(:,1),grpdForBoxplot(:,2),'Labels',...
    {'PN1LS','PN2LS','PN2RS','PN1RS','PN3LS'},'Notch','on')

ylabel('Fract of Postsynaptic Profiles That are PNs')
title({'ORN-->PN Syns Broken Out by Post PN ID',...
    'Each Synapse Counted Once'})
set(gca,'FontSize',18)








grpdForBoxplot=[[(numPNs{1}./numPostEl{1})',zeros(size(numPostEl{1},2),1)];...
    [(numPNs{2}./numPostEl{2})',ones(size(numPostEl{2},2),1)];...
    [(numPNs{3}./numPostEl{3})',2*ones(size(numPostEl{3},2),1)];...
    [(numPNs{4}./numPostEl{4})',3*ones(size(numPostEl{4},2),1)];...
    [(numPNs{5}./numPostEl{5})',4*ones(size(numPostEl{5},2),1)]];


figure()
set(gcf,'color','w')
boxplot(grpdForBoxplot(:,1),grpdForBoxplot(:,2),'Labels',...
    {'PN1LS','PN2LS','PN2RS','PN1RS','PN3LS'},'Notch','on')

ylabel('Fract of Postsynaptic Profiles That are PNs')
title({'ORN-->PN Syns Broken Out by Post PN ID',...
    'Each Synapse Counted Once'})
set(gca,'FontSize',18)





grpdForBoxplot2=[[[numPostEl{1}'; numPostEl{2}';numPostEl{5}'],...
    zeros(numel([numPostEl{1}'; numPostEl{2}';numPostEl{5}']),1)];...
    [[numPostEl{3}'; numPostEl{4}'],...
    ones(numel([numPostEl{3}'; numPostEl{4}']),1)]];

figure()
set(gcf,'color','w')
boxplot(grpdForBoxplot2(:,1),grpdForBoxplot2(:,2),'Labels',...
    {'Left PNs','Right PNs'},'Notch','on')

ylabel('Num Post Prof')
title('ORN-->PN Syns Broken Out by Post PN ID')
set(gca,'FontSize',18)






%% Load annotations and connectors


% Load annotations json. Generated by Wei's code gen_annotation_map.py
annotations=loadjson('~/tracing/sid_by_annotation.json');

% Return all skeleton IDs for R and L ORNs

ORNs_Left=annotations.Left_0x20_ORN;
ORNs_Right=annotations.Right_0x20_ORN;

ORNs=[ORNs_Left, ORNs_Right];

%return all skeleton IDs of DM6 PNs
% PNs=annotations.PN;
PNs=sort(annotations.DM6_0x20_PN);
leftPNs=PNs([1,2,5]);
rightPNs=PNs([3,4]);


% return all skel IDs with *LN* in fieldname
Fn = fieldnames(annotations);
selFn = Fn(~cellfun(@isempty,regexp(Fn,'LN')));

LNs=[];
for i = 1:numel(selFn)
    LNs=[LNs, annotations.(selFn{i})];
end

LNs = unique(LNs);

%
% LNs=annotations.LN;
% LNs=[LNs, annotations.potential_0x20_LN];
% LNs=[LNs, annotations.Prospective_0x20_LN];
% LNs=[LNs, annotations.Likely_0x20_LN];


%Load the connector structure
load('~/tracing/conns.mat')

%gen conn fieldname list
connFields=fieldnames(conns);


%%

leftCountsPoly=[];
rightCountsPoly=[];

for c = 1:length(connFields)
    
    curConnID=cell2mat(connFields(c));
    
    %Make sure the connector doesnt have an empty presynaptic field
    if isempty(conns.(curConnID).pre) == 1
        
        %or an empty postsynaptic field, if its empty it will be a cell
    elseif iscell(conns.(curConnID).post) == 1
        
    else
        
        pre=conns.(curConnID).pre;
        post=conns.(curConnID).post;
        
        if ismember(pre,ORNs)==1 && sum(ismember(post,PNs))>0
            
            if sum(ismember(post,leftPNs))>0
                leftCountsPoly=[leftCountsPoly;[ sum(ismember(post,PNs)),...
                    numel(post)]];
                
            elseif sum(ismember(post,rightPNs))>0
                
                rightCountsPoly=[rightCountsPoly;[ sum(ismember(post,PNs)),...
                    numel(post)]];
                
            end
        end
    end
end




%%

wLeft=[];
wRight=[];

for l=1:length(leftCountsPoly)
    
    for i=1:leftCountsPoly(l,1)
        wLeft=[wLeft;leftCountsPoly(l,2)];
    end
    
end


for l=1:length(rightCountsPoly)
    
    for i=1:rightCountsPoly(l,1)
        
        wRight=[wRight;rightCountsPoly(l,2)];
        
    end
    
end






